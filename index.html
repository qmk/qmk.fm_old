<!doctype html>
<html >
<head>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <meta http-equiv="Content-Style-Type" content="text/css" />

  <link rel="stylesheet" type="text/css" href="/template.css" />

  <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />



<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script type='text/javascript' src='/menu/js/jquery.cookie.js'></script>
<script type='text/javascript' src='/menu/js/jquery.hoverIntent.minified.js'></script>
<script type='text/javascript' src='/menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

<link href="/menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
<link href="/menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
<link href="/menu/css/skins/grey.css" rel="stylesheet" type="text/css" />
  
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
  
  <script src="/script.js"></script>
  
    <script src="/jquery.sticky-kit.js "></script>
  <meta name="generator" content="pandoc" />
  <title>QMK Firmware</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>

    
  <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title"><a href="/">QMK Firmware</a> / <a href="/keyboards/">keyboards</a></span>
        <ul class="nav pull-right doc-info">
          <li><p class="navbar-text"><a href="http://github.com/jackhumbert/qmk_firmware">View on Github</a></p></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="container">
    <div class="row">
            <div id="TOC" class="span4">

            
        <div class="well toc">

        <ul>
        <li><a href="#quantum-mechanical-keyboard-firmware">Quantum Mechanical Keyboard Firmware</a><ul>
        <li><a href="#official-website">Official website</a></li>
        <li><a href="#included-keyboards">Included Keyboards</a></li>
        <li><a href="#maintainers">Maintainers</a></li>
        <li><a href="#documentation-roadmap">Documentation roadmap</a></li>
        </ul></li>
        <li><a href="#getting-started">Getting started</a><ul>
        <li><a href="#build-environment-setup">Build Environment Setup</a><ul>
        <li><a href="#windows-10">Windows 10</a></li>
        <li><a href="#windows-vista-and-later">Windows (Vista and later)</a></li>
        <li><a href="#mac">Mac</a></li>
        <li><a href="#linux">Linux</a></li>
        <li><a href="#docker">Docker</a></li>
        <li><a href="#vagrant">Vagrant</a></li>
        </ul></li>
        <li><a href="#verify-your-installation">Verify Your Installation</a></li>
        </ul></li>
        <li><a href="#customizing-your-keymap">Customizing your keymap</a><ul>
        <li><a href="#the-make-command">The <code>make</code> command</a><ul>
        <li><a href="#simple-instructions-for-building-and-uploading-a-keyboard">Simple instructions for building and uploading a keyboard</a></li>
        <li><a href="#more-detailed-make-instruction">More detailed make instruction</a></li>
        </ul></li>
        <li><a href="#the-makefile">The <code>Makefile</code></a><ul>
        <li><a href="#makefile-options">Makefile options</a></li>
        <li><a href="#customizing-makefile-options-on-a-per-keymap-basis">Customizing Makefile options on a per-keymap basis</a></li>
        </ul></li>
        <li><a href="#the-config.h-file">The <code>config.h</code> file</a></li>
        </ul></li>
        <li><a href="#going-beyond-the-keycodes">Going beyond the keycodes</a><ul>
        <li><a href="#quick-aliases-to-common-actions">Quick aliases to common actions</a><ul>
        <li><a href="#switching-and-toggling-layers">Switching and toggling layers</a></li>
        <li><a href="#fun-with-modifier-keys">Fun with modifier keys</a></li>
        </ul></li>
        <li><a href="#space-cadet-shift-the-future-built-in">Space Cadet Shift: The future, built in</a></li>
        <li><a href="#the-leader-key-a-new-kind-of-modifier">The Leader key: A new kind of modifier</a></li>
        <li><a href="#tap-dance-a-single-key-can-do-3-5-or-100-different-things">Tap Dance: A single key can do 3, 5, or 100 different things</a><ul>
        <li><a href="#examples">Examples</a></li>
        </ul></li>
        <li><a href="#temporarily-setting-the-default-layer">Temporarily setting the default layer</a></li>
        <li><a href="#prevent-stuck-modifiers">Prevent stuck modifiers</a></li>
        <li><a href="#macro-shortcuts-send-a-whole-string-when-pressing-just-one-key">Macro shortcuts: Send a whole string when pressing just one key</a><ul>
        <li><a href="#advanced-macro-functions">Advanced macro functions</a></li>
        </ul></li>
        <li><a href="#dynamic-macros-record-and-replay-macros-in-runtime">Dynamic macros: record and replay macros in runtime</a></li>
        <li><a href="#additional-keycode-aliases-for-software-implemented-layouts-colemak-dvorak-etc">Additional keycode aliases for software-implemented layouts (Colemak, Dvorak, etc)</a></li>
        <li><a href="#additional-language-support">Additional language support</a></li>
        <li><a href="#unicode-support">Unicode support</a></li>
        <li><a href="#backlight-breathing">Backlight Breathing</a></li>
        <li><a href="#other-firmware-shortcut-keycodes">Other firmware shortcut keycodes</a></li>
        </ul></li>
        <li><a href="#custom-quantum-functions">Custom Quantum functions</a><ul>
        <li><a href="#void-matrix_init_void"><code>void matrix_init_*(void)</code></a></li>
        <li><a href="#void-matrix_scan_void"><code>void matrix_scan_*(void)</code></a></li>
        <li><a href="#bool-process_record_uint16_t-keycode-keyrecord_t-record"><code>bool process_record_*(uint16_t keycode, keyrecord_t *record)</code></a></li>
        <li><a href="#void-led_set_uint8_t-usb_led"><code>void led_set_*(uint8_t usb_led)</code></a></li>
        </ul></li>
        <li><a href="#modding-your-keyboard">Modding your keyboard</a><ul>
        <li><a href="#audio-output-from-a-speaker">Audio output from a speaker</a></li>
        <li><a href="#recording-and-playing-back-music">Recording And Playing back Music</a></li>
        <li><a href="#midi-functionalty">MIDI functionalty</a></li>
        <li><a href="#bluetooth-functionality">Bluetooth functionality</a></li>
        <li><a href="#international-characters-on-windows">International Characters on Windows</a></li>
        <li><a href="#rgb-under-glow-mod">RGB Under Glow Mod</a><ul>
        <li><a href="#ws2812-wiring">WS2812 Wiring</a></li>
        </ul></li>
        <li><a href="#safety-considerations">Safety Considerations</a></li>
        </ul></li>
        <li><a href="#porting-your-keyboard-to-qmk">Porting your keyboard to QMK</a><ul>
        <li><a href="#keyboardskeyboardconfig.h"><code>/keyboards/&lt;keyboard&gt;/config.h</code></a></li>
        <li><a href="#keyboardskeyboardmakefile"><code>/keyboards/&lt;keyboard&gt;/Makefile</code></a></li>
        <li><a href="#keyboardskeyboardreadme.md"><code>/keyboards/&lt;keyboard&gt;/readme.md</code></a></li>
        <li><a href="#keyboardskeyboardkeyboard.c"><code>/keyboards/&lt;keyboard&gt;/&lt;keyboard&gt;.c</code></a></li>
        <li><a href="#keyboardskeyboardkeyboard.h"><code>/keyboards/&lt;keyboard&gt;/&lt;keyboard&gt;.h</code></a></li>
        </ul></li>
        <li><a href="#unit-testing">Unit Testing</a><ul>
        <li><a href="#google-test-and-google-mock">Google Test and Google Mock</a></li>
        <li><a href="#use-of-c">Use of C++</a></li>
        <li><a href="#adding-tests-for-new-or-existing-features">Adding tests for new or existing features</a></li>
        <li><a href="#running-the-tests">Running the tests</a></li>
        <li><a href="#debugging-the-tests">Debugging the tests</a></li>
        <li><a href="#full-integration-tests">Full Integration tests</a></li>
        </ul></li>
        <li><a href="#tracing-variables">Tracing variables</a></li>
        </ul>

        </div>


            

      
            

      </div>
            <div class="span8">
            <h1 id="quantum-mechanical-keyboard-firmware"><a href="#quantum-mechanical-keyboard-firmware">Quantum Mechanical Keyboard Firmware</a></h1>
<p><a href="https://travis-ci.org/jackhumbert/qmk_firmware"><embed src="https://travis-ci.org/jackhumbert/qmk_firmware.svg?branch=master" /></a></p>
<p>This is a keyboard firmware based on the <a href="http://github.com/tmk/tmk_keyboard">tmk_keyboard firmware</a> with some useful features for Atmel AVR controllers, and more specifically, the <a href="http://olkb.com">OLKB product line</a>, the <a href="http://www.ergodox-ez.com">ErgoDox EZ</a> keyboard, and the <a href="http://clueboard.co/">Clueboard product line</a>.</p>
<h2 id="official-website"><a href="#official-website">Official website</a></h2>
<p>For an easy-to-read version of this document and the repository, check out <a href="http://qmk.fm"><a href="http://qmk.fm">http://qmk.fm</a></a>. Nicely formatted keyboard and keymap listings are also available there, along with the ability to download .hex files instead of having to setup a build environment and compile them.</p>
<h2 id="included-keyboards"><a href="#included-keyboards">Included Keyboards</a></h2>
<ul>
<li><a href="/keyboards/planck/">Planck</a><br /></li>
<li><a href="/keyboards/preonic/">Preonic</a><br /></li>
<li><a href="/keyboards/atomic/">Atomic</a><br /></li>
<li><a href="/keyboards/ergodox/">ErgoDox EZ</a><br /></li>
<li><a href="/keyboards/clueboard/">Clueboard</a><br /></li>
<li><a href="/keyboards/cluepad/">Cluepad</a></li>
</ul>
<p>The project also includes community support for <a href="/keyboards/">lots of other keyboards</a>.</p>
<h2 id="maintainers"><a href="#maintainers">Maintainers</a></h2>
<p>QMK is developed and maintained by Jack Humbert of OLKB with contributions from the community, and of course, <a href="https://github.com/tmk">Hasu</a>. This repo used to be a fork of <a href="https://github.com/tmk/tmk_keyboard">TMK</a>, and we are incredibly grateful for his founding contributions to the firmware. We've had to break the fork due to purely technical reasons - it simply became too different over time, and we've had to start refactoring some of the basic bits and pieces. We are huge fans of TMK and Hasu :)</p>
<p>This documentation is edited and maintained by Erez Zukerman of ErgoDox EZ. If you spot any typos or inaccuracies, please <a href="https://github.com/jackhumbert/qmk_firmware/issues/new">open an issue</a>.</p>
<p>The OLKB product firmwares are maintained by <a href="https://github.com/jackhumbert">Jack Humbert</a>, the Ergodox EZ by <a href="https://github.com/ezuk">Erez Zukerman</a>, and the Clueboard by <a href="https://github.com/skullydazed">Zach White</a>.</p>
<h2 id="documentation-roadmap"><a href="#documentation-roadmap">Documentation roadmap</a></h2>
<p>This is not a tiny project. While this is the main readme, there are many other files you might want to consult. Here are some points of interest:</p>
<ul>
<li>The readme for your own keyboard: This is found under <code>keyboards/&lt;your keyboards's name&gt;/</code>. So for the ErgoDox EZ, it's <a href="keyboards/ergodox/ez/">here</a>; for the Planck, it's <a href="keyboards/planck/">here</a> and so on.<br /></li>
<li>The list of possible keycodes you can use in your keymap is actually spread out in a few different places:<br /></li>
<li><a href="doc/keycode.txt">doc/keycode.txt</a> - an explanation of those same keycodes.<br /></li>
<li><a href="quantum/keymap.h">quantum/keymap.h</a> - this is where the QMK-specific aliases are all set up. Things like the Hyper and Meh key, the Leader key, and all of the other QMK innovations. These are also explained and documented below, but <code>keymap.h</code> is where they're actually defined.<br /></li>
<li>The <a href="doc/TMK_README.md">TMK documentation</a>. QMK is based on TMK, and this explains how it works internally.</li>
</ul>
<h1 id="getting-started"><a href="#getting-started">Getting started</a></h1>
<p>Before you are able to compile, you'll need to install an environment for AVR development. You'll find the instructions for any OS below. If you find another/better way to set things up from scratch, please consider <a href="https://github.com/jackhumbert/qmk_firmware/pulls">making a pull request</a> with your changes!</p>
<h2 id="build-environment-setup"><a href="#build-environment-setup">Build Environment Setup</a></h2>
<h3 id="windows-10"><a href="#windows-10">Windows 10</a></h3>
<p>It's still recommended to use the method for Vista and later below. The reason for this is that the Windows 10 Subsystem for Linux lacks <a href="https://wpdev.uservoice.com/forums/266908-command-prompt-console-bash-on-ubuntu-on-windo/suggestions/13355724-unable-to-access-usb-devices-from-bash">USB support</a>, so it's not possible to flash the firmware to the keyboard. Please add your vote to the link!</p>
<p>That said, it's still possible to use it for compilation. And recommended, if you need to compile much, since it's much faster than at least Cygwin (which is also supported, but currently lacking documentation). I haven't tried the method below, so I'm unable to tell.</p>
<p>Here are the steps</p>
<ol>
<li>Install the Windows 10 subsystem for Linux, following <a href="http://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-shell-on-windows-10/">these instructions</a>.<br /></li>
<li>If you have previously cloned the repository using the normal Git bash, you will need to clean up the line endings. If you have cloned it after 20th of August 2016, you are likely fine. To clean up the line endings do the following<br /></li>
<li>Make sure that you have no changes you haven't committed by running <code>git status</code>, if you do commit them first<br /></li>
<li>From within the Git bash run <code>git rm --cached -r .</code><br /></li>
<li>Followed by <code>git reset --hard</code><br /></li>
<li>Start the &quot;Bash On Ubuntu On Windows&quot; from the start menu<br /></li>
<li>With the bash open, navigate to your Git checkout. The harddisk can be accessed from <code>/mnt</code> for example <code>/mnt/c</code> for the <code>c:\</code> drive.<br /></li>
<li>Run <code>sudo util/install_dependencies.sh</code>.<br /></li>
<li>After a while the installation will finish, and you are good to go</li>
</ol>
<p><strong>Note</strong> From time to time, the dependencies might change, so just run <code>install_dependencies.sh</code> again if things are not working.</p>
<p><strong>Warning:</strong> If you edit Makefiles or shell scripts, make sure you are using an editor that saves the files with Unix line endings. Otherwise the compilation might not work.</p>
<h3 id="windows-vista-and-later"><a href="#windows-vista-and-later">Windows (Vista and later)</a></h3>
<ol>
<li>If you have ever installed WinAVR, uninstall it.<br /></li>
<li>Install <a href="https://infernoembedded.com/sites/default/files/project/MHV_AVR_Tools_20131101.exe">MHV AVR Tools</a>. Disable smatch, but <strong>be sure to leave the option to add the tools to the PATH checked</strong>.<br /></li>
<li>If you are going to flash Infinity based keyboards you will need to install dfu-util, refer to the instructions by <a href="https://github.com/kiibohd/controller/wiki/Loading-DFU-Firmware">Input Club</a>.<br /></li>
<li>Install <a href="https://sourceforge.net/projects/mingw/files/Installer/mingw-get-setup.exe/download">MinGW</a>. During installation, uncheck the option to install a graphical user interface. <strong>DO NOT change the default installation folder.</strong> The scripts depend on the default location.<br /></li>
<li>Clone this repository. <a href="https://github.com/jackhumbert/qmk_firmware/archive/master.zip">This link will download it as a zip file, which you'll need to extract.</a> Open the extracted folder in Windows Explorer.<br /></li>
<li>Open the <code>\util</code> folder.<br /></li>
<li>Double-click on the <code>1-setup-path-win</code> batch script to run it. You'll need to accept a User Account Control prompt. Press the spacebar to dismiss the success message in the command prompt that pops up.<br /></li>
<li>Right-click on the <code>2-setup-environment-win</code> batch script, select &quot;Run as administrator&quot;, and accept the User Account Control prompt. This part may take a couple of minutes, and you'll need to approve a driver installation, but once it finishes, your environment is complete!</li>
</ol>
<p>If you have trouble and want to ask for help, it is useful to generate a <em>Win_Check_Output.txt</em> file by running <code>Win_Check.bat</code> in the <code>\util</code> folder.</p>
<h3 id="mac"><a href="#mac">Mac</a></h3>
<p>If you're using <a href="http://brew.sh/">homebrew,</a> you can use the following commands:</p>
<pre><code>brew tap osx-cross/avr
brew install avr-libc
brew install dfu-programmer</code></pre>
<p>This is the recommended method. If you don't have homebrew, <a href="http://brew.sh/">install it!</a> It's very much worth it for anyone who works in the command line.</p>
<p>You can also try these instructions:</p>
<ol>
<li>Install Xcode from the App Store.<br /></li>
<li>Install the Command Line Tools from <code>Xcode-&gt;Preferences-&gt;Downloads</code>.<br /></li>
<li>Install [DFU-Programmer][dfu-prog].</li>
</ol>
<p>If you are going to flash Infinity based keyboards you will also need dfu-util</p>
<pre><code>brew install dfu-util</code></pre>
<h3 id="linux"><a href="#linux">Linux</a></h3>
<p>To ensure you are always up to date, you can just run <code>sudo util/install_dependencies.sh</code>. That should always install all the dependencies needed.</p>
<p>You can also install things manually, but this documentation might not be always up to date with all requirements.</p>
<p>The current requirements are the following, but not all might be needed depending on what you do. Also note that some systems might not have all the dependencies available as packages, or they might be named differently.</p>
<pre><code>build-essential
gcc
unzip
wget
zip
gcc-avr
binutils-avr
avr-libc
dfu-programmer
dfu-util
gcc-arm-none-eabi
binutils-arm-none-eabi
libnewlib-arm-none-eabi
git</code></pre>
<p>Install the dependencies with your favorite package manager.</p>
<p>Debian/Ubuntu example:</p>
<pre><code>sudo apt-get update
sudo apt-get install gcc unzip wget zip gcc-avr binutils-avr avr-libc dfu-programmer dfu-util gcc-arm-none-eabi binutils-arm-none-eabi libnewlib-arm-none-eabi</code></pre>
<h3 id="docker"><a href="#docker">Docker</a></h3>
<p>If this is a bit complex for you, Docker might be the turn-key solution you need. After installing <a href="https://www.docker.com/products/docker">Docker</a>, run the following command at the root of the QMK folder to build a keyboard/keymap:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># You&#39;ll run this every time you want to build a keymap</span>
<span class="co"># modify the keymap and keyboard assigment to compile what you want</span>
<span class="co"># defaults are ergodox/default</span>

<span class="kw">docker</span> run -e keymap=gwen -e keyboard=ergodox --rm -v <span class="ot">$(</span><span class="st">&#39;pwd&#39;</span><span class="ot">)</span>:/qmk:rw edasque/qmk_firmware

<span class="co"># On windows docker seems to have issue with VOLUME tag in Dockerfile, and $(&#39;pwd&#39;) won&#39;t print a windows compliant path, use full path instead like this</span>
<span class="kw">docker</span> run -e keymap=default -e keyboard=ergobop --rm -v D:/Users/Sacapuces/Documents/Repositories/qmk:/qmk:rw edasque/qmk_firmware</code></pre>
<p>This will compile the targetted keyboard/keymap and leave it in your QMK directory for you to flash.</p>
<h3 id="vagrant"><a href="#vagrant">Vagrant</a></h3>
<p>If you have any problems building the firmware, you can try using a tool called Vagrant. It will set up a virtual computer with a known configuration that's ready-to-go for firmware building. OLKB does NOT host the files for this virtual computer. Details on how to set up Vagrant are in the <a href="doc/VAGRANT_GUIDE.md">VAGRANT_GUIDE file</a>.</p>
<h2 id="verify-your-installation"><a href="#verify-your-installation">Verify Your Installation</a></h2>
<ol>
<li>If you haven't already, obtain this repository (<a href="https://github.com/jackhumbert/qmk_firmware"><a href="https://github.com/jackhumbert/qmk_firmware">https://github.com/jackhumbert/qmk_firmware</a></a>). You can either download it as a zip file and extract it, or clone it using the command line tool git or the Github Desktop application.<br /></li>
<li>Open up a terminal or command prompt and navigate to the <code>qmk_firmware</code> folder using the <code>cd</code> command. The command prompt will typically open to your home directory. If, for example, you cloned the repository to your Documents folder, then you would type <code>cd Documents/qmk_firmware</code>. If you extracted the file from a zip, then it may be named <code>qmk_firmware-master</code> instead.<br /></li>
<li>To confirm that you're in the correct location, you can display the contents of your current folder using the <code>dir</code> command on Windows, or the <code>ls</code> command on Linux or Mac. You should see several files, including <code>readme.md</code> and a <code>quantum</code> folder. From here, you need to navigate to the appropriate folder under <code>keyboards/</code>. For example, if you're building for a Planck, run <code>cd keyboards/planck</code>.<br /></li>
<li>Once you're in the correct keyboard-specific folder, run the <code>make</code> command. This should output a lot of information about the build process. More information about the <code>make</code> command can be found below.</li>
</ol>
<h1 id="customizing-your-keymap"><a href="#customizing-your-keymap">Customizing your keymap</a></h1>
<p>In every keymap folder, the following files are recommended:</p>
<ul>
<li><code>config.h</code> - the options to configure your keymap<br /></li>
<li><code>keymap.c</code> - all of your keymap code, required<br /></li>
<li><code>Makefile</code> - the features of QMK that are enabled, required to run <code>make</code> in your keymap folder<br /></li>
<li><code>readme.md</code> - a description of your keymap, how others might use it, and explanations of features</li>
</ul>
<h2 id="the-make-command"><a href="#the-make-command">The <code>make</code> command</a></h2>
<p>The <code>make</code> command is how you compile the firmware into a .hex file, which can be loaded by a dfu programmer (like dfu-progammer via <code>make dfu</code>) or the <a href="https://www.pjrc.com/teensy/loader.html">Teensy loader</a> (only used with Teensys).</p>
<p><strong>NOTE:</strong> To abort a make command press <code>Ctrl-c</code></p>
<p>The following instruction refers to these folders.</p>
<ul>
<li>The <code>root</code> (<code>/</code>) folder is the qmk_firmware folder, in which are <code>doc</code>, <code>keyboard</code>, <code>quantum</code>, etc.<br /></li>
<li>The <code>keyboard</code> folder is any keyboard project's folder, like <code>/keyboards/planck</code>.<br /></li>
<li>The <code>keymap</code> folder is any keymap's folder, like <code>/keyboards/planck/keymaps/default</code>.<br /></li>
<li>The <code>subproject</code> folder is the subproject folder of a keyboard, like <code>/keyboards/ergodox/ez</code></li>
</ul>
<h3 id="simple-instructions-for-building-and-uploading-a-keyboard"><a href="#simple-instructions-for-building-and-uploading-a-keyboard">Simple instructions for building and uploading a keyboard</a></h3>
<p><strong>Most keyboards have more specific instructions in the keyboard specific readme.md file, so please check that first</strong></p>
<p>If the <code>keymap</code> folder contains a file name <code>Makefile</code></p>
<ol>
<li>Change the directory to the <code>keymap</code> folder<br /></li>
<li>Run <code>make &lt;subproject&gt;-&lt;programmer&gt;</code></li>
</ol>
<p>Otherwise, if there's no <code>Makefile</code> in the <code>keymap</code> folder</p>
<ol>
<li>Enter the <code>keyboard</code> folder<br /></li>
<li>Run <code>make &lt;subproject&gt;-&lt;keymap&gt;-&lt;programmer&gt;</code></li>
</ol>
<p>In the above commands, replace:</p>
<ul>
<li><code>&lt;keymap&gt;</code> with the name of your keymap<br /></li>
<li><code>&lt;subproject&gt;</code> with the name of the subproject (revision or sub-model of your keyboard). For example, for Ergodox it can be <code>ez</code> or <code>infinity</code>, and for Planck <code>rev3</code> or <code>rev4</code>.<br /></li>
<li>If the keyboard doesn't have a subproject, or if you are happy with the default (defined in <code>rules.mk</code> file of the <code>keyboard</code> folder), you can leave it out. But remember to also remove the dash (<code>-</code>) from the command.<br /></li>
<li><code>&lt;programmer&gt;</code> The programmer to use. Most keyboards use <code>dfu</code>, but some use <code>teensy</code>. Infinity keyboards use <code>dfu-util</code>. Check the readme file in the keyboard folder to find out which programmer to use.<br /></li>
<li>If you don't add <code>-&lt;programmer</code> to the command line, the firmware will be still be compiled into a hex file, but the upload will be skipped.</li>
</ul>
<p><strong>NOTE:</strong> Some operating systems will refuse to program unless you run the make command as root for example <code>sudo make dfu</code></p>
<h3 id="more-detailed-make-instruction"><a href="#more-detailed-make-instruction">More detailed make instruction</a></h3>
<p>The full syntax of the <code>make</code> command is the following, but parts of the command can be left out if you run it from other directories than the <code>root</code> (as you might already have noticed by reading the simple instructions).</p>
<p><code>&lt;keyboard&gt;-&lt;subproject&gt;-&lt;keymap&gt;-&lt;target&gt;</code>, where:</p>
<ul>
<li><code>&lt;keyboard&gt;</code> is the name of the keyboard, for example <code>planck</code><br /></li>
<li>Use <code>allkb</code> to compile all keyboards<br /></li>
<li><code>&lt;subproject&gt;</code> is the name of the subproject (revision or sub-model of the keyboard). For example, for Ergodox it can be <code>ez</code> or <code>infinity</code>, and for Planck <code>rev3</code> or <code>rev4</code>.<br /></li>
<li>If the keyboard doesn't have any subprojects, it can be left out<br /></li>
<li>To compile the default subproject, you can leave it out, or specify <code>defaultsp</code><br /></li>
<li>Use <code>allsp</code> to compile all subprojects<br /></li>
<li><code>&lt;keymap&gt;</code> is the name of the keymap, for example <code>algernon</code><br /></li>
<li>Use <code>allkm</code> to compile all keymaps<br /></li>
<li><code>&lt;target&gt;</code> will be explained in more detail below.</li>
</ul>
<p><strong>Note:</strong> When you leave some parts of the command out, you should also remove the dash (<code>-</code>).</p>
<p>As mentioned above, there are some shortcuts, when you are in a:</p>
<ul>
<li><code>keyboard</code> folder, the command will automatically fill the <code>&lt;keyboard&gt;</code> part. So you only need to type <code>&lt;subproject&gt;-&lt;keymap&gt;-&lt;target&gt;</code><br /></li>
<li><code>subproject</code> folder, it will fill in both <code>&lt;keyboard&gt;</code> and <code>&lt;subproject&gt;</code><br /></li>
<li><code>keymap</code> folder, then <code>&lt;keyboard&gt;</code> and <code>&lt;keymap&gt;</code> will be filled in. If you need to specify the <code>&lt;subproject&gt;</code> use the following syntax <code>&lt;subproject&gt;-&lt;target&gt;</code><br /></li>
<li>Note in order to support this shortcut, the keymap needs its own Makefile (see the example <a href="/doc/keymap_makefile_example.mk">here</a>)<br /></li>
<li><code>keymap</code> folder of a <code>subproject</code>, then everything except the <code>&lt;target&gt;</code> will be filled in</li>
</ul>
<p>The <code>&lt;target&gt;</code> means the following</p>
<ul>
<li>If no target is given, then it's the same as <code>all</code> below<br /></li>
<li><code>all</code> compiles the keyboard and generates a <code>&lt;keyboard&gt;_&lt;keymap&gt;.hex</code> file in whichever folder you run <code>make</code> from. These files are ignored by git, so don't worry about deleting them when committing/creating pull requests.<br /></li>
<li><code>dfu</code>, <code>teensy</code> or <code>dfu-util</code>, compile and upload the firmware to the keyboard. If the compilation fails, then nothing will be uploaded. The programmer to use depends on the keyboard. For most keyboards it's <code>dfu</code>, but for Infinity keyboards you should use <code>dfu-util</code>, and <code>teensy</code> for standard Teensys. To find out which command you should use for your keyboard, check the keyboard specific readme. <strong>Note</strong> that some operating systems needs root access for these commands to work, so in that case you need to run for example <code>sudo make dfu</code>.<br /></li>
<li><code>clean</code>, cleans the build output folders to make sure that everything is built from scratch. Run this before normal compilation if you have some unexplainable problems.</li>
</ul>
<p>Some other targets are supported but, but not important enough to be documented here. Check the source code of the make files for more information.</p>
<p>You can also add extra options at the end of the make command line, after the target</p>
<ul>
<li><code>make COLOR=false</code> - turns off color output<br /></li>
<li><code>make SILENT=true</code> - turns off output besides errors/warnings<br /></li>
<li><code>make VERBOSE=true</code> - outputs all of the gcc stuff (not interesting, unless you need to debug)<br /></li>
<li><code>make EXTRAFLAGS=-E</code> - Preprocess the code without doing any compiling (useful if you are trying to debug #define commands)</li>
</ul>
<p>The make command itself also has some additional options, type <code>make --help</code> for more information. The most useful is probably <code>-jx</code>, which specifies that you want to compile using more than one CPU, the <code>x</code> represents the number of CPUs that you want to use. Setting that can greatly reduce the compile times, especially if you are compiling many keyboards/keymaps. I usually set it to one less than the number of CPUs that I have, so that I have some left for doing other things while it's compiling. Note that not all operating systems and make versions supports that option.</p>
<p>Here are some examples commands</p>
<ul>
<li><code>make allkb-allsp-allkm</code> builds everything (all keyboards, all subprojects, all keymaps). Running just <code>make</code> from the <code>root</code> will also run this.<br /></li>
<li><code>make</code> from within a <code>keyboard</code> directory, is the same as <code>make keyboard-allsp-allkm</code>, which compiles all subprojects and keymaps of the keyboard. <strong>NOTE</strong> that this behaviour has changed. Previously it compiled just the default keymap.<br /></li>
<li><code>make ergodox-infinity-algernon-clean</code> will clean the build output of the Ergodox Infinity keyboard. This example uses the full syntax and can be run from any folder with a <code>Makefile</code><br /></li>
<li><code>make dfu COLOR=false</code> from within a keymap folder, builds and uploads the keymap, but without color output.</li>
</ul>
<h2 id="the-makefile"><a href="#the-makefile">The <code>Makefile</code></a></h2>
<p>There are 5 different <code>make</code> and <code>Makefile</code> locations:</p>
<ul>
<li>root (<code>/</code>)<br /></li>
<li>keyboard (<code>/keyboards/&lt;keyboard&gt;/</code>)<br /></li>
<li>keymap (<code>/keyboards/&lt;keyboard&gt;/keymaps/&lt;keymap&gt;/</code>)<br /></li>
<li>subproject (<code>/keyboards/&lt;keyboard&gt;/&lt;subproject&gt;</code>)<br /></li>
<li>subproject keymap (<code>/keyboards/&lt;keyboard&gt;/&lt;subproject&gt;/keymaps/&lt;keymap&gt;</code>)</li>
</ul>
<p>The root contains the code used to automatically figure out which keymap or keymaps to compile based on your current directory and commandline arguments. It's considered stable, and shouldn't be modified. The keyboard one will contain the MCU set-up and default settings for your keyboard, and shouldn't be modified unless you are the producer of that keyboard. The keymap Makefile can be modified by users, and is optional. It is included automatically if it exists. You can see an example <a href="/doc/keymap_makefile_example.mk">here</a> - the last few lines are the most important. The settings you set here will override any defaults set in the keyboard Makefile. <strong>The file is required if you want to run <code>make</code> in the keymap folder.</strong></p>
<p>For keyboards and subprojects, the make files are split in two parts <code>Makefile</code> and <code>rules.mk</code>. All settings can be found in the <code>rules.mk</code> file, while the <code>Makefile</code> is just there for support and including the root <code>Makefile</code>. Keymaps contain just one <code>Makefile</code> for simplicity.</p>
<h3 id="makefile-options"><a href="#makefile-options">Makefile options</a></h3>
<p>Set the variables to <code>no</code> to disable them, and <code>yes</code> to enable them.</p>
<p><code>BOOTMAGIC_ENABLE</code></p>
<p>This allows you to hold a key and the salt key (space by default) and have access to a various EEPROM settings that persist over power loss. It's advised you keep this disabled, as the settings are often changed by accident, and produce confusing results that makes it difficult to debug. It's one of the more common problems encountered in help sessions.</p>
<p><code>MOUSEKEY_ENABLE</code></p>
<p>This gives you control over cursor movements and clicks via keycodes/custom functions.</p>
<p><code>EXTRAKEY_ENABLE</code></p>
<p>This allows you to use the system and audio control key codes.</p>
<p><code>CONSOLE_ENABLE</code></p>
<p>This allows you to print messages that can be read using <a href="https://www.pjrc.com/teensy/hid_listen.html"><code>hid_listen</code></a>.</p>
<p>By default, all debug (<em>dprint</em>) print (<em>print</em>, <em>xprintf</em>), and user print (<em>uprint</em>) messages will be enabled. This will eat up a significant portion of the flash and may make the keyboard .hex file too big to program.</p>
<p>To disable debug messages (<em>dprint</em>) and reduce the .hex file size, include <code>#define NO_DEBUG</code> in your <code>config.h</code> file.</p>
<p>To disable print messages (<em>print</em>, <em>xprintf</em>) and user print messages (<em>uprint</em>) and reduce the .hex file size, include <code>#define NO_PRINT</code> in your <code>config.h</code> file.</p>
<p>To disable print messages (<em>print</em>, <em>xprintf</em>) and <strong>KEEP</strong> user print messages (<em>uprint</em>), include <code>#define USER_PRINT</code> in your <code>config.h</code> file.</p>
<p>To see the text, open <code>hid_listen</code> and enjoy looking at your printed messages.</p>
<p><strong>NOTE:</strong> Do not include <em>uprint</em> messages in anything other than your keymap code. It must not be used within the QMK system framework. Otherwise, you will bloat other people's .hex files.</p>
<p><code>COMMAND_ENABLE</code></p>
<p>This enables magic commands, typically fired with the default magic key combo <code>LSHIFT+RSHIFT+KEY</code>. Magic commands include turning on debugging messages (<code>MAGIC+D</code>) or temporarily toggling NKRO (<code>MAGIC+N</code>).</p>
<p><code>SLEEP_LED_ENABLE</code></p>
<p>Enables your LED to breath while your computer is sleeping. Timer1 is being used here. This feature is largely unused and untested, and needs updating/abstracting.</p>
<p><code>NKRO_ENABLE</code></p>
<p>This allows the keyboard to tell the host OS that up to 248 keys are held down at once (default without NKRO is 6). NKRO is off by default, even if <code>NKRO_ENABLE</code> is set. NKRO can be forced by adding <code>#define FORCE_NKRO</code> to your config.h or by binding <code>MAGIC_TOGGLE_NKRO</code> to a key and then hitting the key.</p>
<p><code>BACKLIGHT_ENABLE</code></p>
<p>This enables your backlight on Timer1 and ports B5, B6, or B7 (for now). You can specify your port by putting this in your <code>config.h</code>:</p>
<pre><code>#define BACKLIGHT_PIN B7</code></pre>
<p><code>MIDI_ENABLE</code></p>
<p>This enables MIDI sending and receiving with your keyboard. To enter MIDI send mode, you can use the keycode <code>MI_ON</code>, and <code>MI_OFF</code> to turn it off. This is a largely untested feature, but more information can be found in the <code>quantum/quantum.c</code> file.</p>
<p><code>UNICODE_ENABLE</code></p>
<p>This allows you to send unicode symbols via <code>UC(&lt;unicode&gt;)</code> in your keymap. Only codes up to 0x7FFF are currently supported.</p>
<p><code>UNICODEMAP_ENABLE</code></p>
<p>This allows sending unicode symbols using <code>X(&lt;unicode&gt;)</code> in your keymap. Codes<br />up to 0xFFFFFFFF are supported, including emojis. You will need to maintain<br />a separate mapping table in your keymap file.</p>
<p>Known limitations:</p>
<ul>
<li>Under Mac OS, only codes up to 0xFFFF are supported.<br /></li>
<li>Under Linux ibus, only codes up to 0xFFFFF are supported (but anything important is still under this limit for now).</li>
</ul>
<p>Characters out of range supported by the OS will be ignored.</p>
<p><code>BLUETOOTH_ENABLE</code></p>
<p>This allows you to interface with a Bluefruit EZ-key to send keycodes wirelessly. It uses the D2 and D3 pins.</p>
<p><code>AUDIO_ENABLE</code></p>
<p>This allows you output audio on the C6 pin (needs abstracting). See the <a href="#driving-a-speaker---audio-support">audio section</a> for more information.</p>
<p><code>VARIABLE_TRACE</code></p>
<p>Use this to debug changes to variable values, see the <a href="#tracing-variables">tracing variables</a> section for more information.</p>
<h3 id="customizing-makefile-options-on-a-per-keymap-basis"><a href="#customizing-makefile-options-on-a-per-keymap-basis">Customizing Makefile options on a per-keymap basis</a></h3>
<p>If your keymap directory has a file called <code>Makefile</code> (note the filename), any Makefile options you set in that file will take precedence over other Makefile options for your particular keyboard.</p>
<p>So let's say your keyboard's makefile has <code>BACKLIGHT_ENABLE = yes</code> (or maybe doesn't even list the <code>BACKLIGHT_ENABLE</code> option, which would cause it to be off). You want your particular keymap to not have the debug console, so you make a file called <code>Makefile</code> and specify <code>BACKLIGHT_ENABLE = no</code>.</p>
<p>You can use the <code>doc/keymap_makefile_example.md</code> as a template/starting point.</p>
<h2 id="the-config.h-file"><a href="#the-config.h-file">The <code>config.h</code> file</a></h2>
<p>There are 2 <code>config.h</code> locations:</p>
<ul>
<li>keyboard (<code>/keyboards/&lt;keyboard&gt;/</code>)<br /></li>
<li>keymap (<code>/keyboards/&lt;keyboard&gt;/keymaps/&lt;keymap&gt;/</code>)</li>
</ul>
<p>The keyboard <code>config.h</code> is included only if the keymap one doesn't exist. The format to use for your custom one <a href="/doc/keymap_config_h_example.h">is here</a>. If you want to override a setting from the parent <code>config.h</code> file, you need to do this:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#undef MY_SETTING</span>
<span class="ot">#define MY_SETTING 4</span></code></pre>
<p>For a value of <code>4</code> for this imaginary setting. So we <code>undef</code> it first, then <code>define</code> it.</p>
<p>You can then override any settings, rather than having to copy and paste the whole thing.</p>
<h1 id="going-beyond-the-keycodes"><a href="#going-beyond-the-keycodes">Going beyond the keycodes</a></h1>
<p>Aside from the <a href="doc/keycode.txt">basic keycodes</a>, your keymap can include shortcuts to common operations.</p>
<h2 id="quick-aliases-to-common-actions"><a href="#quick-aliases-to-common-actions">Quick aliases to common actions</a></h2>
<p>Your keymap can include shortcuts to common operations (called &quot;function actions&quot; in tmk).</p>
<p>These functions work the same way that their <code>ACTION_*</code> functions do - they're just quick aliases. To dig into all of the tmk <code>ACTION_*</code> functions, please see the <a href="https://github.com/jackhumbert/qmk_firmware/blob/master/doc/keymap.md#2-action">TMK documentation</a>.</p>
<p>Instead of using <code>FNx</code> when defining <code>ACTION_*</code> functions, you can use <code>F(x)</code> - the benefit here is being able to use more than 32 function actions (up to 4096), if you happen to need them.</p>
<h3 id="switching-and-toggling-layers"><a href="#switching-and-toggling-layers">Switching and toggling layers</a></h3>
<p><code>MO(layer)</code> - momentary switch to <em>layer</em>. As soon as you let go of the key, the layer is deactivated and you pop back out to the previous layer. When you apply this to a key, that same key must be set as <code>KC_TRNS</code> on the destination layer. Otherwise, you won't make it back to the original layer when you release the key (and you'll get a keycode sent). You can only switch to layers <em>above</em> your current layer. If you're on layer 0 and you use <code>MO(1)</code>, that will switch to layer 1 just fine. But if you include <code>MO(3)</code> on layer 5, that won't do anything for you -- because layer 3 is lower than layer 5 on the stack.</p>
<p><code>OSL(layer)</code> - momentary switch to <em>layer</em>, as a one-shot operation. So if you have a key that's defined as <code>OSL(1)</code>, and you tap that key, then only the very next keystroke would come from layer 1. You would drop back to layer zero immediately after that one keystroke. That's handy if you have a layer full of custom shortcuts -- for example, a dedicated key for closing a window. So you tap your one-shot layer mod, then tap that magic 'close window' key, and keep typing like a boss. Layer 1 would remain active as long as you hold that key down, too (so you can use it like a momentary toggle-layer key with extra powers).</p>
<p><code>LT(layer, kc)</code> - momentary switch to <em>layer</em> when held, and <em>kc</em> when tapped. Like <code>MO()</code>, this only works upwards in the layer stack (<code>layer</code> must be higher than the current layer).</p>
<p><code>TG(layer)</code> - toggles a layer on or off. As with <code>MO()</code>, you should set this key as <code>KC_TRNS</code> in the destination layer so that tapping it again actually toggles back to the original layer. Only works upwards in the layer stack.</p>
<p><code>TO(layer)</code> - Goes to a layer. This code is special, because it lets you go either up or down the stack -- just goes directly to the layer you want. So while other codes only let you go <em>up</em> the stack (from layer 0 to layer 3, for example), <code>TO(2)</code> is going to get you to layer 2, no matter where you activate it from -- even if you're currently on layer 5. This gets activated on keydown (as soon as the key is pressed).</p>
<h3 id="fun-with-modifier-keys"><a href="#fun-with-modifier-keys">Fun with modifier keys</a></h3>
<ul>
<li><code>LSFT(kc)</code> - applies left Shift to <em>kc</em> (keycode) - <code>S(kc)</code> is an alias<br /></li>
<li><code>RSFT(kc)</code> - applies right Shift to <em>kc</em><br /></li>
<li><code>LCTL(kc)</code> - applies left Control to <em>kc</em><br /></li>
<li><code>RCTL(kc)</code> - applies right Control to <em>kc</em><br /></li>
<li><code>LALT(kc)</code> - applies left Alt to <em>kc</em><br /></li>
<li><code>RALT(kc)</code> - applies right Alt to <em>kc</em><br /></li>
<li><code>LGUI(kc)</code> - applies left GUI (command/win) to <em>kc</em><br /></li>
<li><code>RGUI(kc)</code> - applies right GUI (command/win) to <em>kc</em><br /></li>
<li><code>HYPR(kc)</code> - applies Hyper (all modifiers) to <em>kc</em><br /></li>
<li><code>MEH(kc)</code> - applies Meh (all modifiers except Win/Cmd) to <em>kc</em><br /></li>
<li><code>LCAG(kc)</code> - applies CtrlAltGui to <em>kc</em></li>
</ul>
<p>You can also chain these, like this:</p>
<pre><code>LALT(LCTL(KC_DEL)) -- this makes a key that sends Alt, Control, and Delete in a single keypress.</code></pre>
<p>The following shortcuts automatically add <code>LSFT()</code> to keycodes to get commonly used symbols. Their long names are also available and documented in <code>/quantum/keymap_common.h</code>.</p>
<pre><code>KC_TILD  ~
KC_EXLM  !
KC_AT    @
KC_HASH  #
KC_DLR   $
KC_PERC  %
KC_CIRC  ^
KC_AMPR  &amp;
KC_ASTR  *
KC_LPRN  (
KC_RPRN  )
KC_UNDS  _
KC_PLUS  +
KC_DQUO  &quot;
KC_LCBR  {
KC_RCBR  }
KC_LABK  &lt;
KC_RABK  &gt;
KC_PIPE  |
KC_COLN  :</code></pre>
<p><code>OSM(mod)</code> - this is a &quot;one shot&quot; modifier. So let's say you have your left Shift key defined as <code>OSM(MOD_LSFT)</code>. Tap it, let go, and Shift is &quot;on&quot; -- but only for the next character you'll type. So to write &quot;The&quot;, you don't need to hold down Shift -- you tap it, tap t, and move on with life. And if you hold down the left Shift key, it just works as a left Shift key, as you would expect (so you could type THE). There's also a magical, secret way to &quot;lock&quot; a modifier by tapping it multiple times. If you want to learn more about that, open an issue. :)</p>
<p><code>MT(mod, kc)</code> - is <em>mod</em> (modifier key - MOD_LCTL, MOD_LSFT) when held, and <em>kc</em> when tapped. In other words, you can have a key that sends Esc (or the letter O or whatever) when you tap it, but works as a Control key or a Shift key when you hold it down.</p>
<p>These are the values you can use for the <code>mod</code> in <code>MT()</code> and <code>OSM()</code> (right-hand modifiers are not available for <code>MT()</code>):</p>
<ul>
<li>MOD_LCTL<br /></li>
<li>MOD_LSFT<br /></li>
<li>MOD_LALT<br /></li>
<li>MOD_LGUI<br /></li>
<li>MOD_HYPR<br /></li>
<li>MOD_MEH</li>
</ul>
<p>These can also be combined like <code>MOD_LCTL | MOD_LSFT</code> e.g. <code>MT(MOD_LCTL | MOD_LSFT, KC_ESC)</code> which would activate Control and Shift when held, and send Escape when tapped.</p>
<p>We've added shortcuts to make common modifier/tap (mod-tap) mappings more compact:</p>
<ul>
<li><code>CTL_T(kc)</code> - is LCTL when held and <em>kc</em> when tapped<br /></li>
<li><code>SFT_T(kc)</code> - is LSFT when held and <em>kc</em> when tapped<br /></li>
<li><code>ALT_T(kc)</code> - is LALT when held and <em>kc</em> when tapped<br /></li>
<li><code>GUI_T(kc)</code> - is LGUI when held and <em>kc</em> when tapped<br /></li>
<li><code>ALL_T(kc)</code> - is Hyper (all mods) when held and <em>kc</em> when tapped. To read more about what you can do with a Hyper key, see <a href="http://brettterpstra.com/2012/12/08/a-useful-caps-lock-key/">this blog post by Brett Terpstra</a><br /></li>
<li><code>LCAG_T(kc)</code> - is CtrlAltGui when held and <em>kc</em> when tapped<br /></li>
<li><code>MEH_T(kc)</code> - is like Hyper, but not as cool -- does not include the Cmd/Win key, so just sends Alt+Ctrl+Shift.</li>
</ul>
<h2 id="space-cadet-shift-the-future-built-in"><a href="#space-cadet-shift-the-future-built-in">Space Cadet Shift: The future, built in</a></h2>
<p>Steve Losh <a href="http://stevelosh.com/blog/2012/10/a-modern-space-cadet/">described</a> the Space Cadet Shift quite well. Essentially, you hit the left Shift on its own, and you get an opening parenthesis; hit the right Shift on its own, and you get the closing one. When hit with other keys, the Shift key keeps working as it always does. Yes, it's as cool as it sounds.</p>
<p>To use it, use <code>KC_LSPO</code> (Left Shift, Parens Open) for your left Shift on your keymap, and <code>KC_RSPC</code> (Right Shift, Parens Close) for your right Shift.</p>
<p>It's defaulted to work on US keyboards, but if your layout uses different keys for parenthesis, you can define those in your <code>config.h</code> like this:</p>
<pre><code>#define LSPO_KEY KC_9
#define RSPC_KEY KC_0</code></pre>
<p>You can also choose between different rollover behaviors of the shift keys by defining:</p>
<pre><code>#define DISABLE_SPACE_CADET_ROLLOVER</code></pre>
<p>in your <code>config.h</code>. Disabling rollover allows you to use the opposite shift key to cancel the space cadet state in the event of an erroneous press instead of emitting a pair of parentheses when the keys are released.</p>
<p>The only other thing you're going to want to do is create a <code>Makefile</code> in your keymap directory and set the following:</p>
<pre><code>COMMAND_ENABLE   = no  # Commands for debug and configuration</code></pre>
<p>This is just to keep the keyboard from going into command mode when you hold both Shift keys at the same time.</p>
<h2 id="the-leader-key-a-new-kind-of-modifier"><a href="#the-leader-key-a-new-kind-of-modifier">The Leader key: A new kind of modifier</a></h2>
<p>If you've ever used Vim, you know what a Leader key is. If not, you're about to discover a wonderful concept. :) Instead of hitting Alt+Shift+W for example (holding down three keys at the same time), what if you could hit a <em>sequence</em> of keys instead? So you'd hit our special modifier (the Leader key), followed by W and then C (just a rapid succession of keys), and something would happen.</p>
<p>That's what <code>KC_LEAD</code> does. Here's an example:</p>
<ol>
<li>Pick a key on your keyboard you want to use as the Leader key. Assign it the keycode <code>KC_LEAD</code>. This key would be dedicated just for this -- it's a single action key, can't be used for anything else.<br /></li>
<li>Include the line <code>#define LEADER_TIMEOUT 300</code> somewhere in your keymap.c file, probably near the top. The 300 there is 300ms -- that's how long you have for the sequence of keys following the leader. You can tweak this value for comfort, of course.<br /></li>
<li>Within your <code>matrix_scan_user</code> function, do something like this:</li>
</ol>
<pre><code>LEADER_EXTERNS();

void matrix_scan_user(void) {
  LEADER_DICTIONARY() {
    leading = false;
    leader_end();

    SEQ_ONE_KEY(KC_F) {
      register_code(KC_S);
      unregister_code(KC_S);
    }
    SEQ_TWO_KEYS(KC_A, KC_S) {
      register_code(KC_H);
      unregister_code(KC_H);
    }
    SEQ_THREE_KEYS(KC_A, KC_S, KC_D) {
      register_code(KC_LGUI);
      register_code(KC_S);
      unregister_code(KC_S);
      unregister_code(KC_LGUI);
    }
  }
}</code></pre>
<p>As you can see, you have three function. you can use - <code>SEQ_ONE_KEY</code> for single-key sequences (Leader followed by just one key), and <code>SEQ_TWO_KEYS</code> and <code>SEQ_THREE_KEYS</code> for longer sequences. Each of these accepts one or more keycodes as arguments. This is an important point: You can use keycodes from <strong>any layer on your keyboard</strong>. That layer would need to be active for the leader macro to fire, obviously.</p>
<h2 id="tap-dance-a-single-key-can-do-3-5-or-100-different-things"><a href="#tap-dance-a-single-key-can-do-3-5-or-100-different-things">Tap Dance: A single key can do 3, 5, or 100 different things</a></h2>
<p>Hit the semicolon key once, send a semicolon. Hit it twice, rapidly -- send a colon. Hit it three times, and your keyboard's LEDs do a wild dance. That's just one example of what Tap Dance can do. It's one of the nicest community-contributed features in the firmware, conceived and created by <a href="https://github.com/algernon">algernon</a> in <a href="https://github.com/jackhumbert/qmk_firmware/pull/451">#451</a>. Here's how algernon describes the feature:</p>
<p>With this feature one can specify keys that behave differently, based on the amount of times they have been tapped, and when interrupted, they get handled before the interrupter.</p>
<p>To make it clear how this is different from <code>ACTION_FUNCTION_TAP</code>, lets explore a certain setup! We want one key to send <code>Space</code> on single tap, but <code>Enter</code> on double-tap.</p>
<p>With <code>ACTION_FUNCTION_TAP</code>, it is quite a rain-dance to set this up, and has the problem that when the sequence is interrupted, the interrupting key will be send first. Thus, <code>SPC a</code> will result in <code>a SPC</code> being sent, if they are typed within <code>TAPPING_TERM</code>. With the tap dance feature, that'll come out as <code>SPC a</code>, correctly.</p>
<p>The implementation hooks into two parts of the system, to achieve this: into <code>process_record_quantum()</code>, and the matrix scan. We need the latter to be able to time out a tap sequence even when a key is not being pressed, so <code>SPC</code> alone will time out and register after <code>TAPPING_TERM</code> time.</p>
<p>But lets start with how to use it, first!</p>
<p>First, you will need <code>TAP_DANCE_ENABLE=yes</code> in your <code>Makefile</code>, because the feature is disabled by default. This adds a little less than 1k to the firmware size. Next, you will want to define some tap-dance keys, which is easiest to do with the <code>TD()</code> macro, that - similar to <code>F()</code>, takes a number, which will later be used as an index into the <code>tap_dance_actions</code> array.</p>
<p>This array specifies what actions shall be taken when a tap-dance key is in action. Currently, there are three possible options:</p>
<ul>
<li><code>ACTION_TAP_DANCE_DOUBLE(kc1, kc2)</code>: Sends the <code>kc1</code> keycode when tapped once, <code>kc2</code> otherwise. When the key is held, the appropriate keycode is registered: <code>kc1</code> when pressed and held, <code>kc2</code> when tapped once, then pressed and held.<br /></li>
<li><code>ACTION_TAP_DANCE_FN(fn)</code>: Calls the specified function - defined in the user keymap - with the final tap count of the tap dance action.<br /></li>
<li><code>ACTION_TAP_DANCE_FN_ADVANCED(on_each_tap_fn, on_dance_finished_fn, on_dance_reset_fn)</code>: Calls the first specified function - defined in the user keymap - on every tap, the second function on when the dance action finishes (like the previous option), and the last function when the tap dance action resets.</li>
</ul>
<p>The first option is enough for a lot of cases, that just want dual roles. For example, <code>ACTION_TAP_DANCE(KC_SPC, KC_ENT)</code> will result in <code>Space</code> being sent on single-tap, <code>Enter</code> otherwise.</p>
<p>And that's the bulk of it!</p>
<p>And now, on to the explanation of how it works!</p>
<p>The main entry point is <code>process_tap_dance()</code>, called from <code>process_record_quantum()</code>, which is run for every keypress, and our handler gets to run early. This function checks whether the key pressed is a tap-dance key. If it is not, and a tap-dance was in action, we handle that first, and enqueue the newly pressed key. If it is a tap-dance key, then we check if it is the same as the already active one (if there's one active, that is). If it is not, we fire off the old one first, then register the new one. If it was the same, we increment the counter and the timer.</p>
<p>This means that you have <code>TAPPING_TERM</code> time to tap the key again, you do not have to input all the taps within that timeframe. This allows for longer tap counts, with minimal impact on responsiveness.</p>
<p>Our next stop is <code>matrix_scan_tap_dance()</code>. This handles the timeout of tap-dance keys.</p>
<p>For the sake of flexibility, tap-dance actions can be either a pair of keycodes, or a user function. The latter allows one to handle higher tap counts, or do extra things, like blink the LEDs, fiddle with the backlighting, and so on. This is accomplished by using an union, and some clever macros.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3>
<p>Here's a simple example for a single definition:</p>
<ol>
<li>In your <code>makefile</code>, add <code>TAP_DANCE_ENABLE = yes</code><br /></li>
<li>In your <code>config.h</code> (which you can copy from <code>qmk_firmware/keyboards/planck/config.h</code> to your keymap directory), add <code>#define TAPPING_TERM 200</code><br /></li>
<li>In your <code>keymap.c</code> file, define the variables and definitions, then add to your keymap:</li>
</ol>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//Tap Dance Declarations</span>
<span class="kw">enum</span> {
  TD_ESC_CAPS = <span class="dv">0</span>
};

<span class="co">//Tap Dance Definitions</span>
qk_tap_dance_action_t tap_dance_actions[] = {
  <span class="co">//Tap once for Esc, twice for Caps Lock</span>
  [TD_ESC_CAPS]  = ACTION_TAP_DANCE_DOUBLE(KC_ESC, KC_CAPS)
<span class="co">// Other declarations would go here, separated by commas, if you have them</span>
};

<span class="co">//In Layer declaration, add tap dance item in place of a key code</span>
TD(TD_ESC_CAPS)</code></pre>
<p>Here's a more complex example involving custom actions:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">enum</span> {
 CT_SE = <span class="dv">0</span>,
 CT_CLN,
 CT_EGG,
 CT_FLSH,
};

<span class="co">/* Have the above three on the keymap, TD(CT_SE), etc... */</span>

<span class="dt">void</span> dance_cln_finished (qk_tap_dance_state_t *state, <span class="dt">void</span> *user_data) {
  <span class="kw">if</span> (state-&gt;count == <span class="dv">1</span>) {
    register_code (KC_RSFT);
    register_code (KC_SCLN);
  } <span class="kw">else</span> {
    register_code (KC_SCLN);
  }
}

<span class="dt">void</span> dance_cln_reset (qk_tap_dance_state_t *state, <span class="dt">void</span> *user_data) {
  <span class="kw">if</span> (state-&gt;count == <span class="dv">1</span>) {
    unregister_code (KC_RSFT);
    unregister_code (KC_SCLN);
  } <span class="kw">else</span> {
    unregister_code (KC_SCLN);
  }
}

<span class="dt">void</span> dance_egg (qk_tap_dance_state_t *state, <span class="dt">void</span> *user_data) {
  <span class="kw">if</span> (state-&gt;count &gt;= <span class="dv">100</span>) {
    SEND_STRING (<span class="st">&quot;Safety dance!&quot;</span>);
    reset_tap_dance (state);
  }
}

<span class="co">// on each tap, light up one led, from right to left</span>
<span class="co">// on the forth tap, turn them off from right to left</span>
<span class="dt">void</span> dance_flsh_each(qk_tap_dance_state_t *state, <span class="dt">void</span> *user_data) {
  <span class="kw">switch</span> (state-&gt;count) {
  <span class="kw">case</span> <span class="dv">1</span>:
    ergodox_right_led_3_on();
    <span class="kw">break</span>;
  <span class="kw">case</span> <span class="dv">2</span>:
    ergodox_right_led_2_on();
    <span class="kw">break</span>;
  <span class="kw">case</span> <span class="dv">3</span>:
    ergodox_right_led_1_on();
    <span class="kw">break</span>;
  <span class="kw">case</span> <span class="dv">4</span>:
    ergodox_right_led_3_off();
    _delay_ms(<span class="dv">50</span>);
    ergodox_right_led_2_off();
    _delay_ms(<span class="dv">50</span>);
    ergodox_right_led_1_off();
  }
}

<span class="co">// on the fourth tap, set the keyboard on flash state</span>
<span class="dt">void</span> dance_flsh_finished(qk_tap_dance_state_t *state, <span class="dt">void</span> *user_data) {
  <span class="kw">if</span> (state-&gt;count &gt;= <span class="dv">4</span>) {
    reset_keyboard();
    reset_tap_dance(state);
  }
}

<span class="co">// if the flash state didnt happen, then turn off leds, left to right</span>
<span class="dt">void</span> dance_flsh_reset(qk_tap_dance_state_t *state, <span class="dt">void</span> *user_data) {
  ergodox_right_led_1_off();
  _delay_ms(<span class="dv">50</span>);
  ergodox_right_led_2_off();
  _delay_ms(<span class="dv">50</span>);
  ergodox_right_led_3_off();
}

qk_tap_dance_action_t tap_dance_actions[] = {
  [CT_SE]  = ACTION_TAP_DANCE_DOUBLE (KC_SPC, KC_ENT)
 ,[CT_CLN] = ACTION_TAP_DANCE_FN_ADVANCED (NULL, dance_cln_finished, dance_cln_reset)
 ,[CT_EGG] = ACTION_TAP_DANCE_FN (dance_egg)
 ,[CT_FLSH] = ACTION_TAP_DANCE_FN_ADVANCED (dance_flsh_each, dance_flsh_finished, dance_flsh_reset)
};</code></pre>
<h2 id="temporarily-setting-the-default-layer"><a href="#temporarily-setting-the-default-layer">Temporarily setting the default layer</a></h2>
<p><code>DF(layer)</code> - sets default layer to <em>layer</em>. The default layer is the one at the &quot;bottom&quot; of the layer stack - the ultimate fallback layer. This currently does not persist over power loss. When you plug the keyboard back in, layer 0 will always be the default. It is theoretically possible to work around that, but that's not what <code>DF</code> does.</p>
<h2 id="prevent-stuck-modifiers"><a href="#prevent-stuck-modifiers">Prevent stuck modifiers</a></h2>
<p>Consider the following scenario:</p>
<ol>
<li>Layer 0 has a key defined as Shift.<br /></li>
<li>The same key is defined on layer 1 as the letter A.<br /></li>
<li>User presses Shift.<br /></li>
<li>User switches to layer 1 for whatever reason.<br /></li>
<li>User releases Shift, or rather the letter A.<br /></li>
<li>User switches back to layer 0.</li>
</ol>
<p>Shift was actually never released and is still considered pressed.</p>
<p>If such situation bothers you add this to your <code>config.h</code>:</p>
<pre><code>#define PREVENT_STUCK_MODIFIERS</code></pre>
<p>This option uses 5 bytes of memory per every 8 keys on the keyboard<br />rounded up (5 bits per key). For example on Planck (48 keys) it uses<br />(48/8)*5 = 30 bytes.</p>
<h2 id="macro-shortcuts-send-a-whole-string-when-pressing-just-one-key"><a href="#macro-shortcuts-send-a-whole-string-when-pressing-just-one-key">Macro shortcuts: Send a whole string when pressing just one key</a></h2>
<p>Instead of using the <code>ACTION_MACRO</code> function, you can simply use <code>M(n)</code> to access macro <em>n</em> - <em>n</em> will get passed into the <code>action_get_macro</code> as the <code>id</code>, and you can use a switch statement to trigger it. This gets called on the keydown and keyup, so you'll need to use an if statement testing <code>record-&gt;event.pressed</code> (see keymap_default.c).</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">const</span> macro_t *action_get_macro(keyrecord_t *record, <span class="dt">uint8_t</span> id, <span class="dt">uint8_t</span> opt) <span class="co">// this is the function signature -- just copy/paste it into your keymap file as it is.</span>
{
  <span class="kw">switch</span>(id) {
    <span class="kw">case</span> <span class="dv">0</span>: <span class="co">// this would trigger when you hit a key mapped as M(0)</span>
      <span class="kw">if</span> (record-&gt;event.pressed) {
        <span class="kw">return</span> MACRO( I(<span class="dv">255</span>), T(H), T(E), T(L), T(L), W(<span class="dv">255</span>), T(O), END  ); <span class="co">// this sends the string &#39;hello&#39; when the macro executes</span>
      }
      <span class="kw">break</span>;
  }
  <span class="kw">return</span> MACRO_NONE;
};</code></pre>
<p>A macro can include the following commands:</p>
<ul>
<li>I() change interval of stroke in milliseconds.<br /></li>
<li>D() press key.<br /></li>
<li>U() release key.<br /></li>
<li>T() type key(press and release).<br /></li>
<li>W() wait (milliseconds).<br /></li>
<li>END end mark.</li>
</ul>
<p>So above you can see the stroke interval changed to 255ms between each keystroke, then a bunch of keys being typed, waits a while, then the macro ends.</p>
<p>Note: Using macros to have your keyboard send passwords for you is possible, but a bad idea.</p>
<h3 id="advanced-macro-functions"><a href="#advanced-macro-functions">Advanced macro functions</a></h3>
<p>To get more control over the keys/actions your keyboard takes, the following functions are available to you in the <code>action_get_macro</code> function block:</p>
<ul>
<li><code>record-&gt;event.pressed</code></li>
</ul>
<p>This is a boolean value that can be tested to see if the switch is being pressed or released. An example of this is</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">if</span> (record-&gt;event.pressed) {
  <span class="co">// on keydown</span>
} <span class="kw">else</span> {
  <span class="co">// on keyup</span>
}</code></pre>
<ul>
<li><code>register_code(&lt;kc&gt;);</code></li>
</ul>
<p>This sends the <code>&lt;kc&gt;</code> keydown event to the computer. Some examples would be <code>KC_ESC</code>, <code>KC_C</code>, <code>KC_4</code>, and even modifiers such as <code>KC_LSFT</code> and <code>KC_LGUI</code>.</p>
<ul>
<li><code>unregister_code(&lt;kc&gt;);</code></li>
</ul>
<p>Parallel to <code>register_code</code> function, this sends the <code>&lt;kc&gt;</code> keyup event to the computer. If you don't use this, the key will be held down until it's sent.</p>
<ul>
<li><code>layer_on(&lt;n&gt;);</code></li>
</ul>
<p>This will turn on the layer <code>&lt;n&gt;</code> - the higher layer number will always take priority. Make sure you have <code>KC_TRNS</code> for the key you're pressing on the layer you're switching to, or you'll get stick there unless you have another plan.</p>
<ul>
<li><code>layer_off(&lt;n&gt;);</code></li>
</ul>
<p>This will turn off the layer <code>&lt;n&gt;</code>.</p>
<ul>
<li><code>clear_keyboard();</code></li>
</ul>
<p>This will clear all mods and keys currently pressed.</p>
<ul>
<li><code>clear_mods();</code></li>
</ul>
<p>This will clear all mods currently pressed.</p>
<ul>
<li><code>clear_keyboard_but_mods();</code></li>
</ul>
<p>This will clear all keys besides the mods currently pressed.</p>
<ul>
<li><code>update_tri_layer(layer_1, layer_2, layer_3);</code></li>
</ul>
<p>If the user attempts to activate layer 1 AND layer 2 at the same time (for example, by hitting their respective layer keys), layer 3 will be activated. Layers 1 and 2 will <em>also</em> be activated, for the purposes of fallbacks (so a given key will fall back from 3 to 2, to 1 -- and only then to 0).</p>
<h4 id="naming-your-macros"><a href="#naming-your-macros">Naming your macros</a></h4>
<p>If you have a bunch of macros you want to refer to from your keymap, while keeping the keymap easily readable, you can just name them like so:</p>
<pre><code>#define AUD_OFF M(6)
#define AUD_ON M(7)
#define MUS_OFF M(8)
#define MUS_ON M(9)
#define VC_IN M(10)
#define VC_DE M(11)
#define PLOVER M(12)
#define EXT_PLV M(13)</code></pre>
<p>As was done on the <a href="/keyboards/planck/keymaps/default/keymap.c#L33-L40">Planck default keymap</a></p>
<h4 id="timer-functionality"><a href="#timer-functionality">Timer functionality</a></h4>
<p>It's possible to start timers and read values for time-specific events - here's an example:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">uint16_t</span> key_timer;
key_timer = timer_read();
<span class="kw">if</span> (timer_elapsed(key_timer) &lt; <span class="dv">100</span>) {
  <span class="co">// do something if less than 100ms have passed</span>
} <span class="kw">else</span> {
  <span class="co">// do something if 100ms or more have passed</span>
}</code></pre>
<p>It's best to declare the <code>static uint16_t key_timer;</code> outside of the macro block (top of file, etc).</p>
<h4 id="example-single-key-copypaste-hold-to-copy-tap-to-paste"><a href="#example-single-key-copypaste-hold-to-copy-tap-to-paste">Example: Single-key copy/paste (hold to copy, tap to paste)</a></h4>
<p>With QMK, it's easy to make one key do two things, as long as one of those things is being a modifier. :) So if you want a key to act as Ctrl when held and send the letter R when tapped, that's easy: <code>CTL_T(KC_R)</code>. But what do you do when you want that key to send Ctrl-V (paste) when tapped, and Ctrl-C (copy) when held?</p>
<p>Here's what you do:</p>
<pre><code>static uint16_t key_timer;

const macro_t *action_get_macro(keyrecord_t *record, uint8_t id, uint8_t opt)
{
      switch(id) {
        case 0: {
            if (record-&gt;event.pressed) {
                key_timer = timer_read(); // if the key is being pressed, we start the timer.
            }
            else { // this means the key was just released, so we can figure out how long it was pressed for (tap or &quot;held down&quot;).
                if (timer_elapsed(key_timer) &gt; 150) { // 150 being 150ms, the threshhold we pick for counting something as a tap.
                    return MACRO( D(LCTL), T(C), U(LCTL), END  );
                }
                else {
                    return MACRO( D(LCTL), T(V), U(LCTL), END  );
                }
            }
            break;
        }
      }
    return MACRO_NONE;
};</code></pre>
<p>And then, to assign this macro to a key on your keyboard layout, you just use <code>M(0)</code> on the key you want to press for copy/paste.</p>
<h2 id="dynamic-macros-record-and-replay-macros-in-runtime"><a href="#dynamic-macros-record-and-replay-macros-in-runtime">Dynamic macros: record and replay macros in runtime</a></h2>
<p>In addition to the static macros described above, you may enable the dynamic macros which you may record while writing. They are forgotten as soon as the keyboard is unplugged. Only two such macros may be stored at the same time, with the total length of 64 keypresses (by default).</p>
<p>To enable them, first add a new element to the <code>planck_keycodes</code> enum -- <code>DYNAMIC_MACRO_RANGE</code>:</p>
<pre><code>enum planck_keycodes {
  QWERTY = SAFE_RANGE,
  COLEMAK,
  DVORAK,
  PLOVER,
  LOWER,
  RAISE,
  BACKLIT,
  EXT_PLV,
  DYNAMIC_MACRO_RANGE,
};</code></pre>
<p>Afterwards create a new layer called <code>_DYN</code>:</p>
<pre><code>#define _DYN 6    /* almost any other free number should be ok */</code></pre>
<p>Below these two modifications include the <code>dynamic_macro.h</code> header:</p>
<pre><code>#include &quot;dynamic_macro.h&quot;`</code></pre>
<p>Then define the <code>_DYN</code> layer with the following keys: <code>DYN_REC_START1</code>, <code>DYN_MACRO_PLAY1</code>,<code>DYN_REC_START2</code> and <code>DYN_MACRO_PLAY2</code>. It may also contain other keys, it doesn't matter apart from the fact that you won't be able to record these keys in the dynamic macros.</p>
<pre><code>[_DYN]= {
    {_______,  DYN_REC_START1, DYN_MACRO_PLAY1, _______, _______, _______, _______, _______, _______, _______, _______, _______},
    {_______,  DYN_REC_START2, DYN_MACRO_PLAY2, _______, _______, _______, _______, _______, _______, _______, _______, _______},
    {_______,  _______,        _______,         _______, _______, _______, _______, _______, _______, _______, _______, _______},
    {_______,  _______,        _______,         _______, _______, _______, _______, _______, _______, _______, _______, _______}
},</code></pre>
<p>Add the following code to the very beginning of your <code>process_record_user()</code> function:</p>
<pre><code>if (!process_record_dynamic_macro(keycode, record)) {
    return false;
}</code></pre>
<p>To start recording the macro, press either <code>DYN_REC_START1</code> or <code>DYN_REC_START2</code>. To finish the recording, press the <code>_DYN</code> layer button. The handler awaits specifically for the <code>MO(_DYN)</code> keycode as the &quot;stop signal&quot; so please don't use any fancy ways to access this layer, use the regular <code>MO()</code> modifier. To replay the macro, press either <code>DYN_MACRO_PLAY1</code> or <code>DYN_MACRO_PLAY2</code>.</p>
<p>If the LED-s start blinking during the recording with each keypress, it means there is no more space for the macro in the macro buffer. To fit the macro in, either make the other macro shorter (they share the same buffer) or increase the buffer size by setting the <code>DYNAMIC_MACRO_SIZE</code> preprocessor macro (default value: 128; please read the comments for it in the header).</p>
<p>For the details about the internals of the dynamic macros, please read the comments in the <code>dynamic_macro.h</code> header.</p>
<h2 id="additional-keycode-aliases-for-software-implemented-layouts-colemak-dvorak-etc"><a href="#additional-keycode-aliases-for-software-implemented-layouts-colemak-dvorak-etc">Additional keycode aliases for software-implemented layouts (Colemak, Dvorak, etc)</a></h2>
<p>Everything is assuming you're in Qwerty (in software) by default, but there is built-in support for using a Colemak or Dvorak layout by including this at the top of your keymap:</p>
<p>#include <keymap_colemak.h></p>
<p>If you use Dvorak, use <code>keymap_dvorak.h</code> instead of <code>keymap_colemak.h</code> for this line. After including this line, you will get access to:</p>
<ul>
<li><code>CM_*</code> for all of the Colemak-equivalent characters<br /></li>
<li><code>DV_*</code> for all of the Dvorak-equivalent characters</li>
</ul>
<p>These implementations assume you're using Colemak or Dvorak on your OS, not on your keyboard - this is referred to as a software-implemented layout. If your computer is in Qwerty and your keymap is in Colemak or Dvorak, this is referred to as a firmware-implemented layout, and you won't need these features.</p>
<p>To give an example, if you're using software-implemented Colemak, and want to get an <code>F</code>, you would use <code>CM_F</code> - <code>KC_F</code> under these same circumstances would result in <code>T</code>.</p>
<h2 id="additional-language-support"><a href="#additional-language-support">Additional language support</a></h2>
<p>In <code>quantum/keymap_extras/</code>, you'll see various language files - these work the same way as the alternative layout ones do. Most are defined by their two letter country/language code followed by an underscore and a 4-letter abbreviation of its name. <code>FR_UGRV</code> which will result in a <code></code> when using a software-implemented AZERTY layout. It's currently difficult to send such characters in just the firmware (but it's being worked on - see Unicode support).</p>
<h2 id="unicode-support"><a href="#unicode-support">Unicode support</a></h2>
<p>You can currently send 4 hex digits with your OS-specific modifier key (RALT for OSX with the &quot;Unicode Hex Input&quot; layout, see <a href="http://www.poynton.com/notes/misc/mac-unicode-hex-input.html">this article</a> to learn more) - this is currently limited to supporting one OS at a time, and requires a recompile for switching. 8 digit hex codes are being worked on. The keycode function is <code>UC(n)</code>, where <em>n</em> is a 4 digit hexidecimal. Enable from the Makefile.</p>
<h2 id="backlight-breathing"><a href="#backlight-breathing">Backlight Breathing</a></h2>
<p>In order to enable backlight breathing, the following line must be added to your config.h file.</p>
<pre><code>#define BACKLIGHT_BREATHING</code></pre>
<p>The following function calls are used to control the breathing effect.</p>
<ul>
<li><code>breathing_enable()</code> - Enable the free-running breathing effect.<br /></li>
<li><code>breathing_disable()</code> - Disable the free-running breathing effect immediately.<br /></li>
<li><code>breathing_self_disable()</code> - Disable the free-running breathing effect after the current effect ends.<br /></li>
<li><code>breathing_toggle()</code> - Toggle the free-running breathing effect.<br /></li>
<li><code>breathing_defaults()</code> - Reset the speed and brightness settings of the breathing effect.</li>
</ul>
<p>The following function calls are used to control the maximum brightness of the breathing effect.</p>
<ul>
<li><code>breathing_intensity_set(value)</code> - Set the brightness of the breathing effect when it is at its max value.<br /></li>
<li><code>breathing_intensity_default()</code> - Reset the brightness of the breathing effect to the default value based on the current backlight intensity.</li>
</ul>
<p>The following function calls are used to control the cycling speed of the breathing effect.</p>
<ul>
<li><code>breathing_speed_set(value)</code> - Set the speed of the breathing effect - how fast it cycles.<br /></li>
<li><code>breathing_speed_inc(value)</code> - Increase the speed of the breathing effect by a fixed value.<br /></li>
<li><code>breathing_speed_dec(value)</code> - Decrease the speed of the breathing effect by a fixed value.<br /></li>
<li><code>breathing_speed_default()</code> - Reset the speed of the breathing effect to the default value.</li>
</ul>
<p>The following example shows how to enable the backlight breathing effect when the FUNCTION layer macro button is pressed:</p>
<pre><code>case MACRO_FUNCTION:
    if (record-&gt;event.pressed)
    {
        breathing_speed_set(3);
        breathing_enable();
        layer_on(LAYER_FUNCTION);
    }
    else
    {
        breathing_speed_set(1);
        breathing_self_disable();
        layer_off(LAYER_FUNCTION);
    }
    break;</code></pre>
<p>The following example shows how to pulse the backlight on-off-on when the RAISED layer macro button is pressed:</p>
<pre><code>case MACRO_RAISED:
  if (record-&gt;event.pressed)
  {
    layer_on(LAYER_RAISED);
    breathing_speed_set(2);
    breathing_pulse();
    update_tri_layer(LAYER_LOWER, LAYER_RAISED, LAYER_ADJUST);
  }
  else
  {
    layer_off(LAYER_RAISED);
    update_tri_layer(LAYER_LOWER, LAYER_RAISED, LAYER_ADJUST);
  }
  break;</code></pre>
<h2 id="other-firmware-shortcut-keycodes"><a href="#other-firmware-shortcut-keycodes">Other firmware shortcut keycodes</a></h2>
<ul>
<li><code>RESET</code> - puts the MCU in DFU mode for flashing new firmware (with <code>make dfu</code>)<br /></li>
<li><code>DEBUG</code> - the firmware into debug mode - you'll need hid_listen to see things<br /></li>
<li><code>BL_ON</code> - turns the backlight on<br /></li>
<li><code>BL_OFF</code> - turns the backlight off<br /></li>
<li><code>BL_&lt;n&gt;</code> - sets the backlight to level <em>n</em><br /></li>
<li><code>BL_INC</code> - increments the backlight level by one<br /></li>
<li><code>BL_DEC</code> - decrements the backlight level by one<br /></li>
<li><code>BL_TOGG</code> - toggles the backlight<br /></li>
<li><code>BL_STEP</code> - steps through the backlight levels</li>
</ul>
<p>Enable the backlight from the Makefile.</p>
<h1 id="custom-quantum-functions"><a href="#custom-quantum-functions">Custom Quantum functions</a></h1>
<p>All of these functions are available in the <code>*_kb()</code> or <code>*_user()</code> variety. <code>kb</code> ones should only be used in the <code>&lt;keyboard&gt;/&lt;keyboard&gt;.c</code> file, and <code>user</code> ones should only be used in the <code>keymap.c</code>. The keyboard ones call the user ones - it's necessary to keep these calls to allow the keymap functions to work correctly.</p>
<h2 id="void-matrix_init_void"><a href="#void-matrix_init_void"><code>void matrix_init_*(void)</code></a></h2>
<p>This function gets called when the matrix is initiated, and can contain start-up code for your keyboard/keymap.</p>
<h2 id="void-matrix_scan_void"><a href="#void-matrix_scan_void"><code>void matrix_scan_*(void)</code></a></h2>
<p>This function gets called at every matrix scan, which is basically as often as the MCU can handle. Be careful what you put here, as it will get run a lot.</p>
<h2 id="bool-process_record_uint16_t-keycode-keyrecord_t-record"><a href="#bool-process_record_uint16_t-keycode-keyrecord_t-record"><code>bool process_record_*(uint16_t keycode, keyrecord_t *record)</code></a></h2>
<p>This function gets called on every keypress/release, and is where you can define custom functionality. The return value is whether or not QMK should continue processing the keycode - returning <code>false</code> stops the execution.</p>
<p>The <code>keycode</code> variable is whatever is defined in your keymap, eg <code>MO(1)</code>, <code>KC_L</code>, etc. and can be switch-cased to execute code whenever a particular code is pressed.</p>
<p>The <code>record</code> variable contains infomation about the actual press:</p>
<pre><code>keyrecord_t record {
  keyevent_t event {
    keypos_t key {
      uint8_t col
      uint8_t row
    }
    bool     pressed
    uint16_t time
  }
}</code></pre>
<p>The conditional <code>if (record-&gt;event.pressed)</code> can tell if the key is being pressed or released, and you can execute code based on that.</p>
<h2 id="void-led_set_uint8_t-usb_led"><a href="#void-led_set_uint8_t-usb_led"><code>void led_set_*(uint8_t usb_led)</code></a></h2>
<p>This gets called whenever there is a state change on your host LEDs (eg caps lock, scroll lock, etc). The LEDs are defined as:</p>
<pre><code>#define USB_LED_NUM_LOCK                0
#define USB_LED_CAPS_LOCK               1
#define USB_LED_SCROLL_LOCK             2
#define USB_LED_COMPOSE                 3
#define USB_LED_KANA                    4</code></pre>
<p>and can be tested against the <code>usb_led</code> with a conditional like <code>if (usb_led &amp; (1&lt;&lt;USB_LED_CAPS_LOCK))</code> - if this is true, you can turn your LED one, otherwise turn it off.</p>
<h1 id="modding-your-keyboard"><a href="#modding-your-keyboard">Modding your keyboard</a></h1>
<h2 id="audio-output-from-a-speaker"><a href="#audio-output-from-a-speaker">Audio output from a speaker</a></h2>
<p>Your keyboard can make sounds! If you've got a Planck, Preonic, or basically any keyboard that allows access to the C6 port, you can hook up a simple speaker and make it beep. You can use those beeps to indicate layer transitions, modifiers, special keys, or just to play some funky 8bit tunes.</p>
<p>The audio code lives in <a href="/quantum/audio/audio.h">quantum/audio/audio.h</a> and in the other files in the audio directory. It's enabled by default on the Planck <a href="/keyboards/planck/keymaps/default/keymap.c">stock keymap</a>. Here are the important bits:</p>
<pre><code>#include &quot;audio.h&quot;</code></pre>
<p>Then, lower down the file:</p>
<pre><code>float tone_startup[][2] = {
    ED_NOTE(_E7 ),
    E__NOTE(_CS7),
    E__NOTE(_E6 ),
    E__NOTE(_A6 ),
    M__NOTE(_CS7, 20)
};</code></pre>
<p>This is how you write a song. Each of these lines is a note, so we have a little ditty composed of five notes here.</p>
<p>Then, we have this chunk:</p>
<pre><code>float tone_qwerty[][2]     = SONG(QWERTY_SOUND);
float tone_dvorak[][2]     = SONG(DVORAK_SOUND);
float tone_colemak[][2]    = SONG(COLEMAK_SOUND);
float tone_plover[][2]     = SONG(PLOVER_SOUND);
float tone_plover_gb[][2]  = SONG(PLOVER_GOODBYE_SOUND);

float music_scale[][2] = SONG(MUSIC_SCALE_SOUND);
float goodbye[][2] = SONG(GOODBYE_SOUND);</code></pre>
<p>Wherein we bind predefined songs (from <a href="/quantum/audio/song_list.h">quantum/audio/song_list.h</a>) into named variables. This is one optimization that helps save on memory: These songs only take up memory when you reference them in your keymap, because they're essentially all preprocessor directives.</p>
<p>So now you have something called <code>tone_plover</code> for example. How do you make it play the Plover tune, then? If you look further down the keymap, you'll see this:</p>
<pre><code>PLAY_NOTE_ARRAY(tone_plover, false, 0); // Signature is: Song name, repeat, rest style</code></pre>
<p>This is inside one of the macros. So when that macro executes, your keyboard plays that particular chime.</p>
<p>&quot;Rest style&quot; in the method signature above (the last parameter) specifies if there's a rest (a moment of silence) between the notes.</p>
<h2 id="recording-and-playing-back-music"><a href="#recording-and-playing-back-music">Recording And Playing back Music</a></h2>
<ul>
<li><code>Music On</code> - Turn music mode on. The default mapping is <code>Lower+Upper+C</code><br /></li>
<li><code>LCTL</code> - start a recording<br /></li>
<li>play some tones<br /></li>
<li><code>LALT</code> - stop recording, stop playing<br /></li>
<li><code>LGUI</code> - play recording<br /></li>
<li><code>LALT</code> - stop playing<br /></li>
<li><code>Music Off</code> - Turn music mode off. The default mapping is <code>Lower+Upper+V</code></li>
</ul>
<h2 id="midi-functionalty"><a href="#midi-functionalty">MIDI functionalty</a></h2>
<p>This is still a WIP, but check out <code>quantum/keymap_midi.c</code> to see what's happening. Enable from the Makefile.</p>
<h2 id="bluetooth-functionality"><a href="#bluetooth-functionality">Bluetooth functionality</a></h2>
<p>This requires <a href="https://www.reddit.com/r/MechanicalKeyboards/comments/3psx0q/the_planck_keyboard_with_bluetooth_guide_and/?ref=search_posts">some hardware changes</a>, but can be enabled via the Makefile. The firmware will still output characters via USB, so be aware of this when charging via a computer. It would make sense to have a switch on the Bluefruit to turn it off at will.</p>
<h2 id="international-characters-on-windows"><a href="#international-characters-on-windows">International Characters on Windows</a></h2>
<p><a href="https://autohotkey.com">AutoHotkey</a> allows Windows users to create custom hotkeys among others.</p>
<p>The method does not require Unicode support in the keyboard itself but depends instead of AutoHotkey running in the background.</p>
<p>First you need to select a modifier combination that is not in use by any of your programs.<br />CtrlAltWin is not used very widely and should therefore be perfect for this.<br />There is a macro defined for a mod-tab combo <code>LCAG_T</code>.<br />Add this mod-tab combo to a key on your keyboard, e.g.: <code>LCAG_T(KC_TAB)</code>.<br />This makes the key behave like a tab key if pressed and released immediately but changes it to the modifier if used with another key.</p>
<p>In the default script of AutoHotkey you can define custom hotkeys.</p>
<pre><code>&lt;^&lt;!&lt;#a::Send, 
&lt;^&lt;!&lt;#&lt;+a::Send, </code></pre>
<p>The hotkeys above are for the combination CtrlAltGui and CtrlAltGuiShift plus the letter a.<br />AutoHotkey inserts the Text right of <code>Send,</code> when this combination is pressed.</p>
<h2 id="rgb-under-glow-mod"><a href="#rgb-under-glow-mod">RGB Under Glow Mod</a></h2>
<p><img src="https://raw.githubusercontent.com/jackhumbert/qmk_firmware/master/keyboards/planck/keymaps/yang/planck-with-rgb-underglow.jpg" alt="Planck with RGB Underglow" /></p>
<p>Here is a quick demo on Youtube (with NPKC KC60) (<a href="https://www.youtube.com/watch?v=VKrpPAHlisY">https://www.youtube.com/watch?v=VKrpPAHlisY</a>).</p>
<p>For this mod, you need an unused pin wiring to DI of WS2812 strip. After wiring the VCC, GND, and DI, you can enable the underglow in your Makefile.</p>
<pre><code>RGBLIGHT_ENABLE = yes</code></pre>
<p>In order to use the underglow animation functions, you need to have <code>#define RGBLIGHT_ANIMATIONS</code> in your <code>config.h</code>.</p>
<p>Please add the following options into your config.h, and set them up according your hardware configuration. These settings are for the <code>F4</code> pin by default:</p>
<pre><code>#define RGB_DI_PIN F4     // The pin your RGB strip is wired to
#define RGBLIGHT_ANIMATIONS    // Require for fancier stuff (not compatible with audio)
#define RGBLED_NUM 14     // Number of LEDs
#define RGBLIGHT_HUE_STEP 10
#define RGBLIGHT_SAT_STEP 17
#define RGBLIGHT_VAL_STEP 17</code></pre>
<p>You'll need to edit <code>RGB_DI_PIN</code> to the pin you have your <code>DI</code> on your RGB strip wired to.</p>
<p>The firmware supports 5 different light effects, and the color (hue, saturation, brightness) can be customized in most effects. To control the underglow, you need to modify your keymap file to assign those functions to some keys/key combinations. For details, please check this keymap. <code>keyboards/planck/keymaps/yang/keymap.c</code></p>
<h3 id="ws2812-wiring"><a href="#ws2812-wiring">WS2812 Wiring</a></h3>
<p><img src="https://raw.githubusercontent.com/jackhumbert/qmk_firmware/master/keyboards/planck/keymaps/yang/WS2812-wiring.jpg" alt="WS2812 Wiring" /></p>
<p>Please note the USB port can only supply a limited amount of power to the keyboard (500mA by standard, however, modern computer and most usb hubs can provide 700+mA.). According to the data of NeoPixel from Adafruit, 30 WS2812 LEDs require a 5V 1A power supply, LEDs used in this mod should not more than 20.</p>
<h2 id="safety-considerations"><a href="#safety-considerations">Safety Considerations</a></h2>
<p>You probably don't want to &quot;brick&quot; your keyboard, making it impossible<br />to rewrite firmware onto it. Here are some of the parameters to show<br />what things are (and likely aren't) too risky.</p>
<ul>
<li>If a keyboard map does not include RESET, then, to get into DFU<br /> mode, you will need to press the reset button on the PCB, which<br /> requires unscrewing some bits.<br /></li>
<li>Messing with tmk_core / common files might make the keyboard<br /> inoperable<br /></li>
<li>Too large a .hex file is trouble; <code>make dfu</code> will erase the block,<br /> test the size (oops, wrong order!), which errors out, failing to<br /> flash the keyboard<br /></li>
<li>DFU tools do /not/ allow you to write into the bootloader (unless<br /> you throw in extra fruitsalad of options), so there is little risk<br /> there.<br /></li>
<li>EEPROM has around a 100000 write cycle. You shouldn't rewrite the<br /> firmware repeatedly and continually; that'll burn the EEPROM<br /> eventually.</li>
</ul>
<h1 id="porting-your-keyboard-to-qmk"><a href="#porting-your-keyboard-to-qmk">Porting your keyboard to QMK</a></h1>
<p>If your keyboard is running an Atmega chip (atmega32u4 and others), it's pretty easy to get things setup for compiling your own firmware to flash onto your board. There is a <code>/util/new_project.sh &lt;keyboard&gt;</code> script to help get you started - you can simply pass your keyboard's name into the script, and all of the necessary files will be created. The components of each are described below.</p>
<h2 id="keyboardskeyboardconfig.h"><a href="#keyboardskeyboardconfig.h"><code>/keyboards/&lt;keyboard&gt;/config.h</code></a></h2>
<p>The <code>USB Device descriptor parameter</code> block contains parameters are used to uniquely identify your keyboard, but they don't really matter to the machine.</p>
<p>Your <code>MATRIX_ROWS</code> and <code>MATRIX_COLS</code> are the numbers of rows and cols in your keyboard matrix - this may be different than the number of actual rows and columns on your keyboard. There are some tricks you can pull to increase the number of keys in a given matrix, but most keyboards are pretty straight-forward.</p>
<p>The <code>MATRIX_ROW_PINS</code> and <code>MATRIX_COL_PINS</code> are the pins your MCU uses on each row/column. Your schematic (if you have one) will have this information on it, and the values will vary depending on your setup. This is one of the most important things to double-check in getting your keyboard setup correctly.</p>
<p>For the <code>DIODE_DIRECTION</code>, most hand-wiring guides will instruct you to wire the diodes in the <code>COL2ROW</code> position, but it's possible that they are in the other - people coming from EasyAVR often use <code>ROW2COL</code>. Nothing will function if this is incorrect.</p>
<p><code>BACKLIGHT_PIN</code> is the pin that your PWM-controlled backlight (if one exists) is hooked-up to. Currently only B5, B6, and B7 are supported.</p>
<p><code>BACKLIGHT_BREATHING</code> is a fancier backlight feature that adds breathing/pulsing/fading effects to the backlight. It uses the same timer as the normal backlight. These breathing effects must be called by code in your keymap.</p>
<p><code>BACKLIGHT_LEVELS</code> is how many levels exist for your backlight - max is 15, and they are computed automatically from this number.</p>
<h2 id="keyboardskeyboardmakefile"><a href="#keyboardskeyboardmakefile"><code>/keyboards/&lt;keyboard&gt;/Makefile</code></a></h2>
<p>The values at the top likely won't need to be changed, since most boards use the <code>atmega32u4</code> chip. The <code>BOOTLOADER_SIZE</code> will need to be adjusted based on your MCU type. It's defaulted to the Teensy, since that's the most common controller. Below is quoted from the <code>Makefile</code>.</p>
<pre><code># Boot Section Size in *bytes*
#   Teensy halfKay   512
#   Teensy++ halfKay 1024
#   Atmel DFU loader 4096
#   LUFA bootloader  4096
#   USBaspLoader     2048
OPT_DEFS += -DBOOTLOADER_SIZE=512</code></pre>
<p>At the bottom of the file, you'll find lots of features to turn on and off - all of these options should be set with <code>?=</code> to allow for the keymap overrides. <code>?=</code> only assigns if the variable was previously undefined. For the full documenation of these features, see the <a href="#makefile-options">Makefile options</a>.</p>
<h2 id="keyboardskeyboardreadme.md"><a href="#keyboardskeyboardreadme.md"><code>/keyboards/&lt;keyboard&gt;/readme.md</code></a></h2>
<p>This is where you'll describe your keyboard - please write as much as you can about it! Talking about default functionality/features is useful here. Feel free to link to external pages/sites if necessary. Images can be included here as well. This file will be rendered into a webpage at qmk.fm/keyboards/<keyboard>/.</p>
<h2 id="keyboardskeyboardkeyboard.c"><a href="#keyboardskeyboardkeyboard.c"><code>/keyboards/&lt;keyboard&gt;/&lt;keyboard&gt;.c</code></a></h2>
<p>This is where all of the custom logic for your keyboard goes - you may not need to put anything in this file, since a lot of things are configured automatically. All of the <code>*_kb()</code> functions are defined here. If you modify them, remember to keep the calls to <code>*_user()</code>, or things in the keymaps might not work. You can read more about the functions <a href="#custom-quantum-functions-for-keyboards-and-keymaps">here</a></p>
<h2 id="keyboardskeyboardkeyboard.h"><a href="#keyboardskeyboardkeyboard.h"><code>/keyboards/&lt;keyboard&gt;/&lt;keyboard&gt;.h</code></a></h2>
<p>Here is where you can (optionally) define your <code>KEYMAP</code> function to remap your matrix into a more readable format. With ortholinear boards, this isn't always necessary, but it can help to accomodate the dead spots on your matrix, where there are keys that take up more than one space (2u, staggering, 6.25u, etc). The example shows the difference between the physical keys, and the matrix design:</p>
<pre><code>#define KEYMAP( \
    k00, k01, k02, \
      k10,  k11   \
) \
{ \
    { k00, k01,   k02 }, \
    { k10, KC_NO, k11 }, \
}</code></pre>
<p>Each of the <code>kxx</code> variables needs to be unique, and usually follows the format <code>k&lt;row&gt;&lt;col&gt;</code>. You can place <code>KC_NO</code> where your dead keys are in your matrix.</p>
<h1 id="unit-testing"><a href="#unit-testing">Unit Testing</a></h1>
<p>If you are new to unit testing, then you can find many good resources on internet. However most of it is scattered around in small pieces here and there, and there's also many different opinions, so I won't give any recommendations.</p>
<p>Instead I recommend these two books, explaining two different styles of Unit Testing in detail.</p>
<ul>
<li>&quot;Test Driven Development: By Example: Kent Beck&quot;<br /></li>
<li>&quot;Growing Object-Oriented Software, Guided By Tests: Steve Freeman, Nat Pryce&quot;</li>
</ul>
<p>If you prefer videos there are Uncle Bob's <a href="https://cleancoders.com/">Clean Coders Videos</a>, which unfortunately cost quite a bit, especially if you want to watch many of them. But James Shore has a free <a href="http://www.jamesshore.com/Blog/Lets-Play">Let's Play</a> video series.</p>
<h2 id="google-test-and-google-mock"><a href="#google-test-and-google-mock">Google Test and Google Mock</a></h2>
<p>It's possible to Unit Test your code using <a href="https://github.com/google/googletest">Google Test</a>. The Google Test framework also includes another component for writing testing mocks and stubs, called &quot;Google Mock&quot;. For information how to write the actual tests, please refer to the documentation on that site.</p>
<h2 id="use-of-c"><a href="#use-of-c">Use of C++</a></h2>
<p>Note that Google Test and therefore any test has to be written in C++, even if the rest of the QMK codebases is written in C. This should hopefully not be a problem even if you don't know any C++, since there's quite clear documentation and examples of the required C++ features, and you can write the rest of the test code almost as you would write normal C. Note that some compiler errors which you might get can look quite scary, but just read carefully what it says, and you should be ok.</p>
<p>One thing to remember, is that you have to append <code>extern &quot;C&quot;</code> around all of your C file includes.</p>
<h2 id="adding-tests-for-new-or-existing-features"><a href="#adding-tests-for-new-or-existing-features">Adding tests for new or existing features</a></h2>
<p>If you want to unit test some feature, then take a look at the existing serial_link tests, in the <code>quantum/serial_link/tests folder</code>, and follow the steps below to create a similar structure.</p>
<ol>
<li>If it doesn't already exist, add a test subfolder to the folder containing the feature.<br /></li>
<li>Create a <code>testlist.mk</code> and a <code>rules.mk</code> file in that folder.<br /></li>
<li>Include those files from the root folder <code>testlist.mk</code>and <code>build_test.mk</code> respectively.<br /></li>
<li>Add a new name for your testgroup to the <code>testlist.mk</code> file. Each group defined there will be a separate executable. And that's how you can support mocking out different parts. Note that it's worth adding some common prefix, just like it's done for the serial_link tests. The reason for that is that the make command allows substring filtering, so this way you can easily run a subset of the tests.<br /></li>
<li>Define the source files and required options in the <code>rules.mk</code> file.<br /></li>
</ol>
<ul>
<li><code>_SRC</code> for source files<br /></li>
<li><code>_DEFS</code> for additional defines<br /></li>
<li><code>_INC</code> for additional include folders<br /></li>
</ul>
<ol>
<li>Write the tests in a new cpp file inside the test folder you created. That file has to be one of the files included from the <code>rules.mk</code> file.</li>
</ol>
<p>Note how there's several different tests, each mocking out a separate part. Also note that each of them only compiles the very minimum that's needed for the tests. It's recommend that you try to do the same. For a relevant video check out <a href="https://www.youtube.com/watch?v=Wmy6g-aVgZI">Matt Hargett &quot;Advanced Unit Testing in C &amp; C++</a></p>
<h2 id="running-the-tests"><a href="#running-the-tests">Running the tests</a></h2>
<p>To run all the tests in the codebase, type <code>make test</code>. You can also run test matching a substring by typing <code>make test-matchingsubstring</code> Note that the tests are always compiled with the native compiler of your platform, so they are also run like any other program on your computer.</p>
<h2 id="debugging-the-tests"><a href="#debugging-the-tests">Debugging the tests</a></h2>
<p>If there are problems with the tests, you can find the executable in the <code>./build/test</code> folder. You should be able to run those with GDB or a similar debugger.</p>
<h2 id="full-integration-tests"><a href="#full-integration-tests">Full Integration tests</a></h2>
<p>It's not yet possible to do a full integration test, where you would compile the whole firmware and define a keymap that you are going to test. However there are plans for doing that, because writing tests that way would probably be easier, at least for people that are not used to unit testing.</p>
<p>In that model you would emulate the input, and expect a certain output from the emulated keyboard.</p>
<h1 id="tracing-variables"><a href="#tracing-variables">Tracing variables</a></h1>
<p>Sometimes you might wonder why a variable gets changed and where, and this can be quite tricky to track down without having a debugger. It's of course possible to manually add print statements to track it, but you can also enable the variable trace feature. This works for both for variables that are changed by the code, and when the variable is changed by some memory corruption.</p>
<p>To take the feature into use add <code>VARIABLE_TRACE=x</code> to the end of you make command. <code>x</code> represents the number of variables you want to trace, which is usually 1.</p>
<p>Then at a suitable place in the code, call <code>ADD_TRACED_VARIABLE</code>, to begin the tracing. For example to trace all the layer changes, you can do this</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> matrix_init_user(<span class="dt">void</span>) {
  ADD_TRACED_VARIABLE(<span class="st">&quot;layer&quot;</span>, &amp;layer_state, <span class="kw">sizeof</span>(layer_state));
}</code></pre>
<p>This will add a traced variable named &quot;layer&quot; (the name is just for your information), which tracks the memory location of <code>layer_state</code>. It tracks 4 bytes (the size of <code>layer_state</code>), so any modification to the variable will be reported. By default you can not specify a size bigger than 4, but you can change it by adding <code>MAX_VARIABLE_TRACE_SIZE=x</code> to the end of the make command line.</p>
<p>In order to actually detect changes to the variables you should call <code>VERIFY_TRACED_VARIABLES</code> around the code that you think that modifies the variable. If a variable is modified it will tell you between which two <code>VERIFY_TRACED_VARIABLES</code> calls the modification happened. You can then add more calls to track it down further. I don't recommend spamming the codebase with calls. It's better to start with a few, and then keep adding them in a binary search fashion. You can also delete the ones you don't need, as each call need to store the file name and line number in the ROM, so you can run out of memory if you add too many calls.</p>
<p>Also remember to delete all the tracing code ones you have found the bug, as you wouldn't want to create a pull request with tracing code.</p>
            </div>
    </div>
  </div>
  <script src="https://vjs.zencdn.net/5.4.4/video.js"></script>

</body>
</html>
